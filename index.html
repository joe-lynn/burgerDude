<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Burger Dude</title>
    <script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var game = new Phaser.Game(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio, Phaser.AUTO, '', { preload: preload, create: create, update: update, render: render });
    var scaleRatio = window.devicePixelRatio / 3;

    //level1mapbullshit
    var mapHeight = 12;
    var mapWidth = 18;
    var worldMapArray = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
        [1, 4, 0, 0, 1, 0, 0, 0, 1, 0, 2, 0, 1, 0, 2, 0, 3, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];

    var burgerArray = [];

    function preload() {

        game.load.image('cloudBackground', 'assets/cloudBackground.png');
        game.load.image('ground', 'assets/platform.png');
        game.load.image('burger', 'assets/burger.png');
        game.load.image('block', 'assets/block.png');
        game.load.image('door', 'assets/door.png');
        game.load.image('withBurgerLeft', 'assets/withBurgerLeft.png');
        game.load.image('withBurgerRight', 'assets/withBurgerRight.png');
        game.load.spritesheet('dude', 'assets/spritesheet.png', 300, 300);
    }

    var player;
    var platforms;
    var cursors;

    var timeSinceLastLeftMove = new Date();
    var timeSinceLastRightMove = new Date();
    var timeSinceLastUpMove = new Date();
    var timeSinceLastDownMove = new Date();

    //right = 1 left = -1
    var playerIsFacing = 1;

    var doors;
    var score = 0;
    var scoreText;

    function create() {
        //makes fullscreen on all devices
        this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
        this.scale.pageAlignHorizontally = true;
        this.scale.pageAlignVertically = true;
        this.scale.setScreenSize( true );

        //  We're going to be using physics, so enable the Arcade Physics system
        game.physics.startSystem(Phaser.Physics.ARCADE);

        //  A simple background for our game
        game.add.sprite(0, 0, 'cloudBackground');

        //sets the game world size based on current map
        game.world.setBounds(0, 0, 100*mapWidth, 100*mapHeight);

        //  The platforms group contains the ground and the 2 ledges we can jump on
        platforms = game.add.group();
        //  We will enable physics for any object that is created in this group
        platforms.enableBody = true;

        doors = game.add.group();
        doors.enableBody = true;

        var burgerCounter = 0;
        //creates teh worlds
        for(var x = 0; x < worldMapArray[0].length; x++) {
            for(var y = 0; y < worldMapArray.length; y++){
                var currentSquare = worldMapArray[y][x];
                if(currentSquare === 0){
                    //this is air so nothing
                } else if(currentSquare === 1){
                    //block
                    var ground = platforms.create(100*x, 100*y, 'block');
                    //  Scale it to fit the width of the game
                    ground.scale.setTo(scaleRatio, scaleRatio);
                    //  This stops it from falling away when you jump on it
                    ground.body.immovable = true;
                } else if(currentSquare === 2) {
                    //burger
                    burgerArray[burgerCounter] = platforms.create(100*x, 100*y, 'burger');
                    //  Scale it to fit the width of the game
                    burgerArray[burgerCounter].scale.setTo(scaleRatio, scaleRatio);
                    //  This stops it from falling away when you jump on it
                    burgerArray[burgerCounter].body.immovable = true;
                    burgerCounter += 1;
                } else if(currentSquare === 3){
                    //create dude
                    player = game.add.sprite(100*x, 100*y, 'dude');

                    //  We need to enable physics on the player
                    game.physics.arcade.enable(player);

                    player.scale.setTo(scaleRatio, scaleRatio);

                    //  Player physics properties
                    player.body.gravity.y = 0;
                    player.body.collideWorldBounds = true;
                } else if(currentSquare === 4) {
                    //door
                    var door = doors.create(100*x, 100*y, 'door');
                    //  Scale it
                    door.scale.setTo(scaleRatio, scaleRatio);
                    //door.body.immovable = true;
                }
            }
        }

        //camera follow
        game.camera.follow(player);

        //  Our two animations, walking left and right.
        player.animations.add('left', [0, 1, 2, 3], 10, true);
        player.animations.add('right', [5, 6, 7, 8], 10, true);

        //  The score
        scoreText = game.add.text(500, 500, 'Not Winner', { fontSize: '32px', fill: '#000' });

        //  Our controls.
        cursors = game.input.keyboard.createCursorKeys();

    }

    function update() {
        //  Collide the player and the stars with the platforms
        game.physics.arcade.collide(player, platforms);
        game.physics.arcade.collide(doors, platforms);

        //  Checks to see if the player overlaps with door
        game.physics.arcade.overlap(player, doors, foundDoor, null, this);

        //  Reset the players velocity (movement)
        player.body.velocity.x = 0;

        //limits moves per second.
        if (cursors.left.isDown){
            if(canMoveTime('left')) {
                canMovePhysics('left');
            }
        } else if (cursors.right.isDown){
            if(canMoveTime('right')){
                canMovePhysics('right');
            }
        } else if(cursors.up.isDown) {
            if(canMoveTime('up')){
                canMovePhysics('up');
            }
        } else if(cursors.down.isDown) {
            if(canMoveTime('down')){
                canMovePhysics('down')
            }
        }
    }

    function canMovePhysics(movement){
        var playerX;
        var playerY;
        for(var x = 0; x < worldMapArray[0].length; x++) {
            for (var y = 0; y < worldMapArray.length; y++) {
                var currentSquare = worldMapArray[y][x];
                if(currentSquare === 3){
                    playerX = x;
                    playerY = y;
                }
            }
        }

        if(movement === 'left'){
            playerIsFacing = -1;
            if(worldMapArray[playerY][playerX - 1] === 0){
                var currentYSquare = playerY;
                var fallAmount = 0;
                while(worldMapArray[currentYSquare + 1][playerX - 1] === 0){
                    currentYSquare += 1;
                    fallAmount += 1;
                }
                //here is the movement that takes into account falling
                player.body.x -= 100;
                player.body.y += 100*fallAmount;
                worldMapArray[playerY][playerX] = 0;
                worldMapArray[playerY + fallAmount][playerX - 1] = 3;
            }
        } else if(movement === 'right') {
            playerIsFacing = 1;
            if(worldMapArray[playerY][playerX + 1] === 0){
                var currentYSquare = playerY;
                var fallAmount = 0;
                while(worldMapArray[currentYSquare + 1][playerX + 1] === 0){
                    currentYSquare += 1;
                    fallAmount += 1;
                }
                //here is the movement that takes into account falling
                player.body.x += 100;
                player.body.y += 100*fallAmount;
                worldMapArray[playerY][playerX] = 0;
                worldMapArray[playerY + fallAmount][playerX + 1] = 3;
            }
        } else if(movement === 'up'){
            if(playerIsFacing === -1){
                if(worldMapArray[playerY - 1][playerX - 1] === 0) {
                    if(worldMapArray[playerY][playerX - 1] !== 0){
                        player.body.x -= 100;
                        player.body.y -= 100;
                        worldMapArray[playerY][playerX] = 0;
                        worldMapArray[playerY - 1][playerX - 1] = 3;
                    }
                }
            } else if(playerIsFacing === 1) {
                if(worldMapArray[playerY - 1][playerX + 1] === 0) {
                    if(worldMapArray[playerY][playerX + 1] !== 0){
                        player.body.x += 100;
                        player.body.y -= 100;
                        worldMapArray[playerY][playerX] = 0;
                        worldMapArray[playerY - 1][playerX + 1] = 3;
                    }
                }
            }
        } else if(movement === 'down'){
            //go through each square and count burgers before burger in question in order to kill correct burger sprite
            if(playerIsFacing === -1){
                if(worldMapArray[playerY][playerX - 1] === 2) {
                    if(worldMapArray[playerY - 1][playerX - 1] === 0){
                        if(worldMapArray[playerY - 1][playerX] === 0){
                            //player picks up burger to left
                            player.body.y -= 100;
                            player.loadTexture('withBurgerLeft', 0);
                        }
                    }
                }
            }
        }
    }

    function canMoveTime(movement){
        if(movement === 'left'){
            if(new Date() - timeSinceLastLeftMove > 100){
                timeSinceLastLeftMove = new Date();
                return true;
            } else {
                return false;
            }
        } else if(movement === 'right') {
            if(new Date() - timeSinceLastRightMove > 100) {
                timeSinceLastRightMove = new Date();
                return true;
            } else {
                return false;
            }
        } else if(movement === 'up') {
            if(new Date() - timeSinceLastUpMove > 100) {
                timeSinceLastUpMove = new Date();
                return true;
            } else {
                return false;
            }
        } else if(movement === 'down') {
            if(new Date() - timeSinceLastDownMove > 100){
                timeSinceLastDownMove = new Date();
                return true;
            } else {
                return false;
            }
        }
    }

    function render(){
        game.debug.spriteInfo(player, 20, 32);
    }

    function foundDoor () {
        scoreText.text = 'WINNER ';

    }

</script>

</body>
</html>